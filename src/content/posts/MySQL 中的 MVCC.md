---
title: MySQL 中的 MVCC
published: 2024-06-25
category: 文章
tags:
  - MySQL
  - 面试题
draft: true
---

# 什么是事务隔离级别

在实际使用场景中，往往会有多个线程同时访问数据库，此时可能会出现不同线程同时读写一条数据的情况。虽然在 InnoDB 中，对单行数据的操作是原子的，但如果同时两个线程还开启了事务，就会引发问题。

常见的由并发读写引起的问题如下，严重性从高到低：

| 问题       | 描述                                                                       |
| ---------- | -------------------------------------------------------------------------- |
| 脏读       | 在事务 A 中，读到了还未提交的事务 B 中修改的数据                           |
| 不可重复读 | 在事务 A 中，在不同时间执行同一条 SQL 时，同一条数据的前后结果不一样       |
| 幻读       | 在事务 A 中，在不同时间执行同一条 SQL 时，前后的结果集不同，行数发生了变动 |

为了解决以上问题，主流数据库引擎中都引入了隔离级别的概念：

| 级别     | 描述                                              |
| -------- | ------------------------------------------------- |
| 读未提交 | 可以看到其他事务中未提交的数据                    |
| 读已提交 | 只能读取到已经提交事务的数据                      |
| 可重复读 | 同一事务内，相同 SQL 语句只会返回第一次查询的结果 |
| 串行化   | 直接限制事务不可并发                              |

可以发现，隔离级别和问题是一一对应的。

`读未提交`就是不做任何措施，会引发最严重的脏读问题。

`读已提交`通过规定只能读取已提交的事务的数据，解决了脏读的问题。但由于如果其他事务在当前事务期间提交了数据，那当前事务前后读取到的数据还是会不一致，所以无法解决不可重复读问题。

`可重复读`通过规定同一事务内，同一 SQL 执行时只在第一次执行实际查询，后续直接返回第一次查询的结果，解决了不可重复读的问题。但由于
